require_relative '../test_helper'

module OpticalReaderTest
  module ServiceTest

    class ValidatorTest < Minitest::Test
      include OpticalReader::Service

      def setup
        @v = Validator.new 'dummy input'
        @fake_img = Tempfile.new 'example.png'
        @real_img = File.open File.expand_path("../../test-images/sample-eng.png", __FILE__)
      end

      def teardown
        @v = nil
        @fake_img.close
        @fake_img.unlink
        @real_img.close
      end

      def test_validate_scan_input
        # not a language & not image type uploads rejected.
        doc = { tempfile: @fake_img }
        @v.input = { language: :unknown, document: doc }
        assert_equal @v.validate_scan_input, false
        assert !@v.errors.empty?
        [:language, :document].each { |k| assert_includes @v.errors.keys, k }
        assert_equal @v.errors[:language].count, 1
        assert_equal @v.errors[:document].count, 1

        # empty upload rejected.
        @v.input = { language: :eng, document: nil }
        assert_equal @v.validate_scan_input, false
        assert !@v.errors.empty?
        assert_includes @v.errors.keys, :document
        refute_includes @v.errors.keys, :language
        assert_equal @v.errors[:document].count, 1

        # large upload rejected.
        # large.png was generated by: `dd of=large.png bs=1024 count=0 seek=$[1024*11]`
        # it's also a fake image, hence errors count = 2
        doc[:tempfile] = File.open File.expand_path("../../test-images/large.png", __FILE__)
        @v.input = { language: :ara, document: doc }
        assert_equal @v.validate_scan_input, false
        assert !@v.errors.empty?
        assert_includes @v.errors.keys, :document
        refute_includes @v.errors.keys, :language
        assert_equal @v.errors[:document].count, 2

        # accepted state.
        doc[:tempfile] = @real_img
        @v.input = { language: :ara, document: doc }
        assert_equal @v.validate_scan_input, true
        assert @v.errors.empty?
      end

      def test_validate_export_input
        @v.input = { reviewed_text: " \n \t " }
        refute @v.validate_export_input
        @v.input = { reviewed_text: "good to go." }
        assert @v.validate_export_input
      end

      def test_validate_wizard_session
        @v.input = {}
        refute @v.validate_wizard_session
        @v.input = { 'language' => '  ', 'document_path' => '  ' }
        refute @v.validate_wizard_session
        @v.input = { 'language' => :eng, 'document_path:' => '\n' }
        refute @v.validate_wizard_session
        @v.input = { 'language' => nil, 'document_path' => '/ocr-uploads/good-path.png' }
        refute @v.validate_wizard_session

        @v.input = { 'language' => :eng, 'document_path' =>  '/ocr-uploads/good-path.png' }
        assert @v.validate_wizard_session
      end

      def test_validate_contact_input
        @v.input = { name: "bb", email: 'a@aaa.', subject: nil, message: '......' }
        assert_equal @v.validate_contact_input, false
        assert !@v.errors.empty?
        [:name, :email, :subject, :type, :message].each do |k|
          assert_includes @v.errors.keys, k
        end
        assert_equal @v.errors[:name].count,    1
        assert_equal @v.errors[:email].count,   2
        assert_equal @v.errors[:subject].count, 1
        assert_equal @v.errors[:message].count, 1

        @v.input = { name: "Bob", email: 'bob@website.com', subject: "Wisdom", type: "4",
                     message: 'Beauty is in the eye of the beholder.' }
        assert_equal @v.validate_contact_input, true
        assert @v.errors.empty?
      end

      def test_blank?
        assert @v.send :blank?, nil
        assert @v.send :blank?, ''
        assert @v.send :blank?, '  '
        assert @v.send :blank?, "\n"
        assert @v.send :blank?, []
        assert @v.send :blank?, {}
        refute @v.send(:blank?, "P")
        refute @v.send(:blank?, 10)
        refute @v.send(:blank?, [10])
        refute @v.send(:blank?, { a: 'b' })
      end

      def test_shorter?
        assert_equal @v.send(:shorter?, "ABC", 4), true
        assert_equal @v.send(:shorter?, "ABCD", 4), false
        assert_equal @v.send(:shorter?, "ABCDE", 4), false
        assert_equal @v.send(:shorter?, nil, 4), nil
      end

      def test_longer?
        assert_equal @v.send(:longer?, "ABC", 4), false
        assert_equal @v.send(:longer?, "ABCD", 4), false
        assert_equal @v.send(:longer?, "ABCDE", 4), true
        assert_equal @v.send(:longer?, nil, 4), nil
      end

      def test_email?
        assert @v.send(:email?, "a@example.com")
        assert @v.send(:email?, "ab.cd@sat.com")
        refute @v.send(:email?, "a@@example.com")
        refute @v.send(:email?, "a@.example.com")
        refute @v.send(:email?, "a@example..com")
        refute @v.send(:email?, "a@example?.com")
      end

      def test_choice?
        assert @v.send(:choice?, "A", ["A", "B", "C"])
        refute @v.send(:choice?, "D", ["A", "B", "C"])
      end

      def test_exceed_size?
        v = Validator.new 'any', 60
        @fake_img.stub(:size, 80) { assert v.send(:exceed_size?, @fake_img) }
        @fake_img.stub(:size, 60) { refute v.send(:exceed_size?, @fake_img) }
        @fake_img.stub(:size, 50) { refute v.send(:exceed_size?, @fake_img) }
      end

      def test_not_image?
        assert_equal @v.send(:not_image?, @fake_img), true
        assert_equal @v.send(:not_image?, @real_img), false
      end
    end

  end
end
